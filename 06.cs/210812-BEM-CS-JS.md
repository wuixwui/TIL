|   date   |  title  |  skill   |
| :------: | :-----: | :------: |
| 21.08.12 | CS + js | html, js |

---

# TIL

1. BEM
2. Thread
3. Virtual Memory
4. Scope
5. Hoisting

---

## BEM

Block Element Modifier

> HTML 클래스 속성의 작명법

- 요소\_\_일부분

  ```html
  <div class="container">
    <div class="container__name"></div>
  </div>
  ```

- 요소—상태

  ```html
  <div class="btn btn--primary"></div>
  <div class="btn btn--success"></div>
  <div class="btn btn--error"></div>
  ```

---

## CS

[[TIL] 08.11 - CS , JS](https://www.notion.so/TIL-08-11-CS-JS-dff4af7e4e114ef39fcf4279b1956ff6)

- 응용프로그램
- API 라이브러리 플랫폼 쉘 컴파일러
- OS
- 하드웨어

---

### Thread (스레드)

> light weight process

하나의 프로세스에 여러개의 스레드 생성가능

스레드 간 자원 공유

**스레드들은 동시에 실행가능**

프로세스 안에 있으므로 **프로세스의 데이터를 모두 접근 가능** (IPC를 사용하지 않아도 된다.)

프로세스의 구조에 스레드를 위한 공간을 생성해서 사용한다.

스레드에는 PC SP를 따로 가지고 있다.

### Multi Thread

부모 프로세스의 코드 데이터 힙 영역을 공유한다.

### 멀티 프로세싱과 Thread

멀티프로세싱: 여러 프로세스를 여러 CPU에 병렬로 실행시킴.

→ 멀티코어 환경에서 스레드를 여러개 만들면 가능하다.

---

### Thread 장점

1. 사용자에 대한 응답성 향상 (스레드 하나는 특정 작업을 하고, 다른 스레드는 사용자와 커뮤니케이션을 하고..)
2. 자원 효율 (프로세스에 비해 용량을 적게 사용하고 IPC가 필요 없다.

### Thread 단점

1. 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받는다.

   멀티 프로세스는 한 프로세스가 문제가 생기면 분리되어 있어서 문제가 생긴 프로세스 외는 영향을 받지 않는다.

2. 스레드를 많이 생성하면 성능이 저하될 수 있다.

### Thread와 Process

- 프로세스는 독립적이고 스레드는 서브셋
- 프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원 공유
- 프로세스는 자신만의 주소영역을 가짐. 스레드는 주소영역 공유
- 프로세스간에는 IPC 기법으로 통신해야함, 스레드는 필요 없음

---

### 동기화 이슈 예제

컨텍스트 스위칭이 원치 않는 상황이 일어날 경우 공유하고 있던 값에 저장이 일어나지 않기 때문에동기화 이슈가 발생할 수 있다.

1. Mutual exclusion 상호 배제

   - 임계 자원 (critical resource)
   - 임계 영역 (critical section)

   = locking 메커니즘

   - mutex 하나만 접근 가능
   - semaphore 동시접근 허용가능 수를 제어

     P: 검사 (임계영역에 들어갈때) - S가 1 이상이면 접근하고 S에서 1제거, 0이면 대기

     - 바쁜 대기: loop를 돌면서 기다리는것
     - 대기큐: 대기상태에 넣고 재움 / V에서 프로세스 재실행

     V: 증가 (임계영역에 나올 때) S에 1을 더하고 나옴

     S: 세마포어 값

2. Deadlock 교착상태

   무한 대기 상태: 두개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 다음 단계로 진행하지 못하는 상태

   교착상태를 방지하기 위해서는 교착상태 조건 중 하나를 제거한다.

3. Starvation 기아상태

   프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태

   - 우선순위 변경하면 해결

---

### 가상메모리

리눅스는 하나의 프로세스가 4Gb

통상 메모리는 8Gb 16Gb (폰노이만 구조는 코드는 반드시 메모리에 있어야함)

---

> 메모리가 실제 메모리보다 많아 보이게 하는 기술

- Virtual address 가상 주소 - 프로세스가 참조하는 주소
- Physical address 물리 주소 - 실제 메모리 주소

**프로세스는 가상 주소를 사용하고 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소 사용**

MMU: 가상 메모리 주소를 물리 주소로 빠르게 변환해 주는 **하드웨어 장치**

### 가상 메모리와 MMU

1. CPU는 가상메모리를 다루고 MMU를 통해 물리 메모리에 접근
2. PCB에서 해당 페이지 테이블 접근 가능, 관련 정보는 물리 메모리에 적재
3. 프로세스 구동시, 해당 페이지 테이블 base 주소가 **별도 레지스터에 저장(CR3)**
4. CPU가 가상 주소 접근시**, MMU가CR3로 페이지 테이블 base 주소를 접근**해서, 물리 주소를 가져옴

---

### 페이징 시스템

- 프로세스를 크기가 동일한 페이지(크기-4Kb)로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
- 내부 단편화 (페이지 블록만큼 데이터가 딱 맞게 채워져 있지 않을 때 공간 낭비 ← 페이지 블록의 크기가 정해져 있기 때문에)
- 하드웨어 지원이 필요

가상 주소 v = (p,d)

- p: 가상 메모리 페이지 번호
- d: p안에서 참조하는 위치 (변위) (0~12bit)

### 페이지 테이블

물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정보를 매핑한 표

**페이지 번호**, **맨 처음의 가상주소, 물리주소, 물리 주소에 있는지 없는지에 대한 정보(i,v)**

PCB에 page table주소 + 페이지 번호를 알면 가상주소에 접근할 수 있다. → 변위 값을 더해주면 실제 물리 주소가 된다.

---

### 다중 단계 페이징 시스템 ..?

페이징 정보를 단계를 나누어 생성

페이지 번호를 나타내는 bit를 구분해서 단계를 나눔

- 10bit (page directory) + 10bit (page table) + 12bit (offset)

---

### MMU와 TLB (컴퓨터 구조)

MMU는 메모리를 갔다와야 하는데 래지스터에 비해 시간이 많이 걸리게 된다.

TLB: 페이지 정보 캐쉬

- 전에 MMU로 작업했던 물리주소를 저장하는 장치

---

### 페이징 시스템과 공유 메모리

프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)

물리 주소 데이터 변경시

- 물리 주소에 데이터 수정 시도시 물리 주소를 복사해서 사용

---

### 요구 페이징

실행 중 필요한 시점에서만 메모리로 적재

- 페이지폴트 **(= 인터럽트)**

  - 어떤 페이지가 물리 데이터 안에 존재하지 않을 때 페이지폴트인터럽트 실행 →

    운영체제가 저장매체에서 해당 데이터를 메모리에 올리고 다시 프로세스를 실행한다.

페이지 폴트가 자주 일어나면 시간이 오래 걸림.

---

### 페이지 교체 정책 (페이징 스왑)

메모리가 다 차면 어떤 페이지를 교체할지에 대한 정책

페이지 교체 알고리즘

- FIFO
- OPT 가장 안 쓸것 같은 페이지를 교체(불가능한 정책)
- LRU 가장 오래전에 사용한 페이지를 교체
- NUR 최근에 사용하지 않은 페이지부터 교체 (읽고,쓰는 것을 기준으로 둘다 하지 않은 것을 먼저 제거)

### 스레싱

반복적으로 페이지 폴트가 발생해서 과도하게 페이지 교체 작업이 일어나서 계속 페이지폴트 - 페이징 스왑만 반복되어서 화면에 아무것도 뜨지 않는 현상

---

### 세그멘테이션

페이징 기법은 가상 메모리를 같은 크기의 블록으로 분할하지만 세그멘테이션은 가상메모리를 서로 크기가 다른 **논리적 단위**의 세그먼트로 분할한다.

물리주소 계산 방식은 페이징 기법과 유사하다.

---

## JS

### Scope

- global 전역 변수
- local (= function) 지역 변수
- block

  : 조건, 반복문 내부에서 사용하는 변수

var 로 변수 선언을 하게 되면 블록 선언을 제한을 무시합니다.

### hoisting

> 선언되지 않은 변수나 함수를 끌어올려서 사용할 수 있는 작동 방식

- 함수 선언이 호출 이후에 선언되어도 호출이 되는 현상

호이스팅은 코드를 이해하기에 방해가 되기 때문에 유지 보수가 어려워지기 때문에 피하는 편이 좋습니다.

var은 호이스팅 현상이 일어나지만 const와 let은 호이스팅 현상이 일어나지 않습니다.

- 호이스팅 방지

```jsx
const myFunction = function myFunction() {
  console.log("hello world");
};
```

함수를 const나 let을 이용해서 호이스팅을 방지 할 수 있다.

혹은 ESLint를 사용하면 코드를 분석해서 알려준다.
